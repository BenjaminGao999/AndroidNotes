gradle 

# 属性、变量 设置

http://www.cnblogs.com/huang0925/p/3318152.html

gradle.properties文件下

ext{
    supportLibraryVersion = '25.4.0'
    constraintLayoutVersion = '1.0.2'
    zxingCoreVersion = '3.2.1'
    amapVersion = 'latest.integration'
    multidexVersion = '1.0.1'
    matisseVersion = '0.5.0-alpha3'

    apiBaseUrlRelease = 'http://api-paper.lxbznkj.com'
    webBaseUrlRelease = 'http://api-paper.lxbznkj.com/#'
    apiBaseUrlDebug = 'http://test-api-paper.lxbznkj.com'
    webBaseUrlDebug = 'http://test-web-paper.lxbznkj.com/#'

    roundViewVersion = '1.1.4@aar'

   aspectjrtVersion ='1.8.9'
}




## gradle编译器， groovy语言

http://wiki.jikexueyuan.com/project/deep-android-gradle/two.html

从编程框架角度看gradle
http://wiki.jikexueyuan.com/project/deep-android-gradle/four-four.html



## classpath

    dependencies {
        classpath 'com.android.tools.build:gradle:3.0.0'
        // 添加AspectJ
        classpath "com.app.plugin:gradleplugin:${aspectj_plugin_version}"
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }

http://www.cnblogs.com/huang0925/p/3940528.html

其实答案非常简单。buildscript中的声明是gradle脚本自身需要使用的资源。
可以声明的资源包括依赖项、第三方插件、maven仓库地址等。而在build.gradle文件中直接声明的依赖项、
仓库地址等信息是项目自身需要的资源。

gradle是由groovy语言编写的，支持groovy语法，可以灵活的使用已有的各种ant插件、基于jvm的类库，
这也是它比maven、ant等构建脚本强大的原因。虽然gradle支持开箱即用，但是如果你想在脚本中使用一些第三方的插件、类库等，
就需要自己手动添加对这些插件、类库的引用。而这些插件、类库又不是直接服务于项目的，而是支持其它build脚本的运行。
所以你应当将这部分的引用放置在buildscript代码块中。gradle在执行脚本时，会优先执行buildscript代码块中的内容，
然后才会执行剩余的build脚本。

举个例子，假设我们要编写一个task，用于解析csv文件并输出其内容。虽然我们可以使用gradle编写解析csv文件的代码，
但其实apache有个库已经实现了一个解析csv文件的库供我们直接使用。
我们如果想要使用这个库，需要在gradle.build文件中加入对该库的引用。


buildscript代码块中的repositories和dependencies的使用方式与直接在build.gradle文件中的使用方式几乎完全一样。
唯一不同之处是在buildscript代码块中你可以对dependencies使用classpath声明。
该classpath声明说明了在执行其余的build脚本时，class loader可以使用这些你提供的依赖项。
这也正是我们使用buildscript代码块的目的。





# 极客公园wiki， gradle自动化构建工具

http://wiki.jikexueyuan.com/project/gradle/dependency-management-basics.html



# 利用android studio 自己写个gradle 插件

https://juejin.im/entry/577bc26e165abd005530ead8

https://blog.csdn.net/eclipsexys/article/details/50973205

其中，除了buildSrc目录以外，都是标准的Android目录，

而buildSrc就是Gradle提供的在项目中配置自定义插件的默认目录，开发Gradle要创建的目录，
也就是RootProject/src/main/groovy和RootProject/src/main/resources两个目录。







### flavor dimension

  /**
     * Specifies the names of product flavor dimensions for this project.
     *
     * <p>When configuring product flavors with Android plugin 3.0.0 and higher, you must specify at
     * least one flavor dimension, using the <a
     * href="com.android.build.gradle.BaseExtension.html#com.android.build.gradle.BaseExtension:flavorDimensions(java.lang.String[])">
     * <code>flavorDimensions</code></a> property, and then assign each flavor to a dimension.
     * Otherwise, you will get the following build error:
     *
     * <pre>
     * Error:All flavors must now belong to a named flavor dimension.
     * The flavor 'flavor_name' is not assigned to a flavor dimension.
     * </pre>
     *
     * <p>By default, when you specify only one dimension, all flavors you configure automatically
     * belong to that dimension. If you specify more than one dimension, you need to manually assign
     * each flavor to a dimension, as shown in the sample below.
     *
     * <p>Flavor dimensions allow you to create groups of product flavors that you can compine with
     * flavors from other flavor dimensions. For example, you can have one dimension that includes a
     * 'free' and 'paid' version of your app, and another dimension for flavors that support
     * different API levels, such as 'minApi21' and 'minApi24'. The Android plugin can then combine
     * flavors from these dimensions—including their settings, code, and resources—to create
     * variants such as 'debugFreeMinApi21' and 'releasePaidMinApi24', and so on. The sample below
     * shows you how to specify flavor dimensions and add product flavors to them.
     *
     * <pre>
     * android {
     *     ...
     *     // Specifies the flavor dimensions you want to use. The order in which you
     *     // list each dimension determines its priority, from highest to lowest,
     *     // when Gradle merges variant sources and configurations. You must assign
     *     // each product flavor you configure to one of the flavor dimensions.
     *     flavorDimensions 'api', 'version'
     *
     *     productFlavors {
     *       demo {
     *         // Assigns this product flavor to the 'version' flavor dimension.
     *         dimension 'version'
     *         ...
     *     }
     *
     *       full {
     *         dimension 'version'
     *         ...
     *       }
     *
     *       minApi24 {
     *         // Assigns this flavor to the 'api' dimension.
     *         dimension 'api'
     *         minSdkVersion '24'
     *         versionNameSuffix "-minApi24"
     *         ...
     *       }
     *
     *       minApi21 {
     *         dimension "api"
     *         minSdkVersion '21'
     *         versionNameSuffix "-minApi21"
     *         ...
     *       }
     *    }
     * }
     * </pre>
     *
     * <p>To learn more, read <a
     * href="https://developer.android.com/studio/build/build-variants.html#flavor-dimensions">
     * Combine multiple flavors</a>.
     */
    public void flavorDimensions(String... dimensions) {
        checkWritability();
        flavorDimensionList = Arrays.asList(dimensions);
    }









